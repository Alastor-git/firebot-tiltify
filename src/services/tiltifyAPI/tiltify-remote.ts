import createClient, { type Client, type Middleware } from "openapi-fetch";
import type { components, paths } from "@/types/TiltifyAPI/schema"; // generated by openapi-typescript

import { TILTIFY_API_BASE_URL } from "@/constants";

import { TiltifyCampaign } from "@/types/campaign";
import { TiltifyCampaignReward } from "@/types/campaign-reward";
import { TiltifyCause } from "@/types/cause";
import { TiltifyDonation } from "@/types/donation";
import { TiltifyPoll } from "@/types/poll";
import { TiltifyMilestone } from "@/types/milestone";

import { logger } from "@/tiltify-logger";
import { AuthDetails } from "@crowbartools/firebot-custom-scripts-types";
import { TiltifyTarget } from "@/types/target";
import { TiltifyAuthManager } from "@/auth-manager";
import { AuthProviderDefinition } from "@crowbartools/firebot-custom-scripts-types/types/modules/auth-manager";
import { TiltifyAPIError } from "@/shared/errors";
import { TiltifyDonationMatch } from "@/types/donation-match";

/**
 * Description placeholder
 *
 * @type {(keyof paths)[]}
 */
const UNPROTECTED_ROUTES: (keyof paths)[] = [
    "/oauth/token",
    "/oauth/authorize"
];

/**
 * Singleton Class that interfaces with Tiltify API
 *
 * @export
 * @class TiltifyAPIController
 * @typedef {TiltifyAPIController}
 */
export class TiltifyAPIController {
    /**
     * Holds the singleton instance of the class
     *
     * @private
     * @static
     * @type {TiltifyAPIController}
     */
    private static _instance: TiltifyAPIController;

    /**
     * Stores the openapi-fetch client that performs communication
     *
     * @private
     * @type {Client<paths, `${string}/${string}`>}
     */
    private client: Client<paths, `${string}/${string}`>;

    /**
     * openapi-fetch Middleware that logs errors in case of unsuccessfull request
     *
     * @private
     * @type {Middleware}
     */
    private errorManagementMiddleware: Middleware = {
        async onResponse({ response }) {
            if (response.ok) {
                return; // Skip the middleware if request was successful
            }
            const { status, statusText, url } = response;
            if (status !== 520) {
                logger.warn(
                        `API error ${status} when requesting "${url}": ${statusText}`
                    );
            }
        },
        async onError({ request, error }) {
            logger.warn(
                `API error when requesting "${request.url}": ${error}`
            );
            // Return an Error 520 for unknown error
            return new Response(null, {
                status: 520,
                statusText: `Unknown API Error: ${error}`
            });
        }
    };

    /**
     * Creates an instance of TiltifyAPIController.
     *
     * @constructor
     * @private
     */
    private constructor() {
        const apiAuthMiddleware: Middleware = {
            async onRequest({ schemaPath, request }) {
                // Return the request unmodified if it's an unprotected route
                if (
                    UNPROTECTED_ROUTES.some((pathname: string) =>
                        schemaPath.startsWith(pathname)
                    )
                ) {
                    return undefined; // don’t modify request for certain paths
                }

                // In all other cases, use Bearer authentication scheme
                // fetch token, if it doesn’t exist
                const authRes: AuthDetails | null =
                    await TiltifyAuthManager.getAuth();
                if (!authRes) {
                    // Error 498	Token expired/invalid
                    throw new TiltifyAPIError(498, `No valid Auth token available to make the API request`);
                }
                const accessToken = authRes.access_token;

                // add Authorization header to every request
                request.headers.set("Authorization", `Bearer ${accessToken}`);
                return request;
            }
        };

        this.client = createClient<paths>({
            baseUrl: `${TILTIFY_API_BASE_URL}`
        });
        this.client.use(this.errorManagementMiddleware);
        this.client.use(apiAuthMiddleware);
    }

    /**
     * Retrieves and if necessary creates the singleton instance of TiltifyAPIController
     *
     * @constructor
     * @public
     * @static
     * @returns {TiltifyAPIController}
     */
    public static instance(): TiltifyAPIController {
        return (
            TiltifyAPIController._instance ||
            (TiltifyAPIController._instance = new TiltifyAPIController())
        );
    }

    /**
     * Checks that the current token is valid by performing a request against the current-user endpoint
     *
     * @async
     * @returns {Promise<boolean>}
     */
    async validateToken(): Promise<boolean> {
        const {
            response,
            data // only present if 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET("/api/public/current-user");
        if (!response.ok || !data?.data) {
            logger.warn(
                `Token validation request failed`
            );
            return false;
        }

        const userData: components["schemas"]["User"] = data.data;
        logger.debug(
            `Token validation request for user ${userData.username} successful`
        );
        return true;
    }

    /**
     * Requests a token from Tiltify
     *
     * @async
     * @param {AuthProviderDefinition} authProvider
     * @param {string} redirectUri
     * @returns {Promise<AuthDetails>}
     * @throws {TiltifyAPIError} if Token can't be acquired
     */
    async createToken(
        authProvider: AuthProviderDefinition,
        redirectUri: string,
        authorizationCode: string
    ): Promise<AuthDetails> {
        // eslint-disable-next-line new-cap
        const { data, error, response } = await this.client.POST(
            "/oauth/token",
            {
                params: {
                    query: {
                        client_id: authProvider.client.id, // eslint-disable-line camelcase
                        client_secret: authProvider.client.secret ?? "", // eslint-disable-line camelcase
                        redirect_uri: redirectUri, // eslint-disable-line camelcase
                        code: authorizationCode,
                        grant_type: "authorization_code", // eslint-disable-line camelcase
                        scope: "public"
                    }
                }
            }
        );
        if (!response.ok || !data) {
            // Error 498	Token expired/invalid
            throw new TiltifyAPIError(498, `Token acquisition request failed`);
        }
        const token: AuthDetails = TiltifyAuthManager.getAuthDetails(
            data as RawTiltifyToken
        );
        logger.debug(`Token acquisition request successful`);
        return token;
    }

    /**
     * Requests for the token to be refreshed
     *
     * @async
     * @param {AuthDetails} expiredToken
     * @param {AuthProviderDefinition} authProvider
     * @returns {Promise<AuthDetails>}
     * @throws {TiltifyAPIError} if Token can't be refreshed
     */
    async refreshToken(
        expiredToken: AuthDetails,
        authProvider: AuthProviderDefinition
    ): Promise<AuthDetails> {
        // eslint-disable-next-line new-cap
        const { data, error, response } = await this.client.POST(
            "/oauth/token",
            {
                params: {
                    query: {
                        client_id: authProvider.client.id, // eslint-disable-line camelcase
                        client_secret: authProvider.client.secret ?? "", // eslint-disable-line camelcase
                        grant_type: "refresh_token", // eslint-disable-line camelcase
                        refresh_token: expiredToken.refresh_token, // eslint-disable-line camelcase
                        scope: "public"
                    }
                }
            }
        );
        if (!response.ok || !data) {
            // Error 498	Token expired/invalid
            throw new TiltifyAPIError(498, `Token refresh request failed`);
        }
        const token: AuthDetails = TiltifyAuthManager.getAuthDetails(
            data as RawTiltifyToken
        );
        logger.debug(`Token refresh request successful`);
        return token;
    }

    /**
     * Retrieves information about a campaign
     *
     * @async
     * @param {string} campaignId
     * @returns {Promise<TiltifyCampaign>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getCampaign(campaignId: string): Promise<TiltifyCampaign> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET("/api/public/campaigns/{campaign_id}", {
            params: { path: { campaign_id: campaignId } } // eslint-disable-line camelcase
        });

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Campaign ${campaignId} data couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Campaign ${campaignId} data couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Campaign ${campaignId} returned no data`);
        }

        const campaignData: components["schemas"]["Campaign"] = data.data;
        return campaignData;
    }

    /**
     * Retrieves all the donations performed to a campaign since completedAfter
     *
     * @async
     * @param {string} campaignId
     * @param {(string | null)} [completedAfter=null]
     * @returns {Promise<TiltifyDonation[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getCampaignDonations(
        campaignId: string,
        completedAfter: string | null = null
    ): Promise<TiltifyDonation[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET(
            "/api/public/campaigns/{campaign_id}/donations",
            {
                params: {
                    path: { campaign_id: campaignId }, // eslint-disable-line camelcase
                    query: completedAfter
                        ? { completed_after: completedAfter } // eslint-disable-line camelcase
                        : undefined
                }
            }
        );

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Donations for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Donations for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Donations for campaign ${campaignId} returned no data`);
        }

        const donationsData: components["schemas"]["Donation"][] = data.data;
        return donationsData;
    }


    /**
     * Retrieves information about donation matches for a campaign
     *
     * @async
     * @param {string} campaignId
     * @param {(string | null)} [updatedAfter=null]
     * @returns {Promise<TiltifyDonationMatch[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getDonationMatches(
        campaignId: string,
        updatedAfter: string | null = null
    ): Promise<TiltifyDonationMatch[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET(
            "/api/public/campaigns/{campaign_id}/donation_matches",
            {
                params: {
                    path: { campaign_id: campaignId }, // eslint-disable-line camelcase
                    query: updatedAfter
                        ? { updated_after: updatedAfter } // eslint-disable-line camelcase
                        : undefined
                }
            }
        );

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Donation matches for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Donation matches for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Donation matches for campaign ${campaignId} returned no data`);
        }

        const donationMatchesData: components["schemas"]["DonationMatch"][] = data.data;
        return donationMatchesData;
    }


    /**
     * Retrieves information about a cause
     *
     * @async
     * @param {string} causeId
     * @returns {Promise<TiltifyCause>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getCause(causeId: string): Promise<TiltifyCause> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET("/api/public/causes/{cause_id}", {
            params: {
                path: { cause_id: causeId } // eslint-disable-line camelcase
            }
        });

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Cause ${causeId} data couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Cause ${causeId} data couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Cause ${causeId} returned no data`);
        }

        const causeData: components["schemas"]["Cause"] = data.data;
        return causeData;
    }

    /**
     * Gets the rewards of a campaign
     *
     * @async
     * @param {string} campaignId
     * @returns {Promise<TiltifyCampaignReward[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getRewards(campaignId: string): Promise<TiltifyCampaignReward[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET(
            "/api/public/campaigns/{campaign_id}/rewards",
            {
                params: {
                    path: { campaign_id: campaignId } // eslint-disable-line camelcase
                }
            }
        );

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Rewards for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Rewards for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Rewards for campaign ${campaignId} returned no data`);
        }

        const rewardsData: components["schemas"]["Reward"][] = data.data;
        return rewardsData;
    }

    /**
     * Gets the poll options of a campaign
     *
     * @async
     * @param {string} campaignId
     * @returns {Promise<TiltifyPoll[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getPollOptions(campaignId: string): Promise<TiltifyPoll[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET("/api/public/campaigns/{campaign_id}/polls", {
            params: {
                path: { campaign_id: campaignId } // eslint-disable-line camelcase
            }
        });

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Polls for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Polls for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Polls for campaign ${campaignId} returned no data`);
        }

        const pollsData: components["schemas"]["Poll"][] = data.data;
        return pollsData;
    }

    /**
     * Gets the list of targets for the campaign
     *
     * @async
     * @param {string} campaignId
     * @returns {Promise<TiltifyTarget[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getTargets(campaignId: string): Promise<TiltifyTarget[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET(
            "/api/public/campaigns/{campaign_id}/targets",
            {
                params: {
                    path: { campaign_id: campaignId } // eslint-disable-line camelcase
                }
            }
        );

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Targets for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Targets for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Targets for campaign ${campaignId} returned no data`);
        }

        const targetsData: components["schemas"]["Target"][] = data.data;
        return targetsData;
    }

    /**
     * Gets the list of Milestones for the campaign
     *
     * @async
     * @param {string} campaignId
     * @returns {Promise<TiltifyMilestone[]>}
     * @throws {TiltifyAPIError} if no Token or request rejected
     */
    async getMilestones(campaignId: string): Promise<TiltifyMilestone[]> {
        const {
            response,
            data, // only present if 2XX response
            error // only present if not 2XX response
            // eslint-disable-next-line new-cap
        } = await this.client.GET(
            "/api/public/campaigns/{campaign_id}/milestones",
            {
                params: {
                    path: { campaign_id: campaignId } // eslint-disable-line camelcase
                }
            }
        );

        if (error?.error) {
            throw new TiltifyAPIError(error.error.status, `Milestones for campaign ${campaignId} couldn't be retrieved: ${error.error.message}`);
        } else if (!response.ok) {
            throw new TiltifyAPIError(response.status, `Milestones for campaign ${campaignId} couldn't be retrieved: ${response.statusText}`);
        } else if (!data?.data) {
            throw new TiltifyAPIError(410, `Milestones for campaign ${campaignId} returned no data`);
        }

        const milestonesData: components["schemas"]["Milestone"][] = data.data;
        return milestonesData;
    }
}

/**
 * Shortcut to TiltifyAPIController instantiator
 *
 * @type {typeof TiltifyAPIController.instance}
 */
export const tiltifyAPIController: typeof TiltifyAPIController.instance =
    TiltifyAPIController.instance.bind(TiltifyAPIController);
